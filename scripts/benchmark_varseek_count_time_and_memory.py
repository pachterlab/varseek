import os
import random
import subprocess
import time

import numpy as np
import pandas as pd
import pysam

import varseek as vk
from varseek.utils import (
    is_program_installed,
    report_time_and_memory_of_script,
    run_command_with_error_logging,
)

all_supported_tools_to_benchmark = {"varseek", "gatk_haplotypecaller", "gatk_mutect2", "strelka2", "varscan"}
tools_that_require_star_alignment = {"gatk_haplotypecaller", "gatk_mutect2", "strelka2", "varscan"}

### ARGUMENTS ###
number_of_reads_list = [1, 4, 16, 64, 256, 1024]  # number of reads, in millions
tools_to_benchmark = {"varseek", "gatk_haplotypecaller", "gatk_mutect2", "strelka2", "varscan"}

read_length = 150
k = 59
w = 54
strand = None  # None for strand-agnostic (randomly-selected), "f" for forward, "r" for reverse, "both" for both - make sure this matches the reference genome (vk build command) - strand = True -> "f" or "r" here; strand = False -> None or "both" here - note that the strand is randomly selected per *transcript*, such that all drawn reads will come from the same strand no matter what
add_noise_sequencing_error = True
add_noise_base_quality = False
error_rate=0.0001  # only if add_noise_sequencing_error=True
error_distribution=(0.85, 0.1, 0.05)  # sub, del, ins  # only if add_noise_sequencing_error=True
max_errors=float("inf")  # only if add_noise_sequencing_error=True
seq_id_column="seq_ID"
mut_column="mutation"
threads = 4
random_seed=42

vk_ref_index_path = "/Users/joeyrich/Documents/Caltech/Pachter/reference/varseek/cosmic_cmc_cdna_Jan25/index.idx"  # for vk count
vk_ref_t2g_path = "/Users/joeyrich/Documents/Caltech/Pachter/reference/varseek/cosmic_cmc_cdna_Jan25/t2g.txt"  # for vk count

cosmic_mutations_path = "cosmic_cmc"  # for vk sim   # can replace with path to csv file generated by gget cosmic
reference_cdna_path = "cdna"  # for vk sim   # can replace with path to cdna fasta file (such as that downloaded by gget ref)
reference_genome_fasta = "/Users/joeyrich/Documents/Caltech/Pachter/reference/ensembl/grch37_release93/Homo_sapiens.GRCh37.dna.primary_assembly.fa"  # for alternative variant calling  #!!!
reference_genome_gtf = "/Users/joeyrich/Documents/Caltech/Pachter/reference/ensembl/grch37_release93/Homo_sapiens.GRCh37.87.gtf"  # for alternative variant calling
genomes1000_vcf = "/home/jrich/data/varseek_data/reference/ensembl/grch37_release93/1000GENOMES-phase_3.vcf"

opt_dir = "/home/jrich/opt"
seqtk = "seqtk"
STAR = os.path.join(opt_dir, "STAR-2.7.11b/bin/Linux_x86_64/STAR")
java = "/home/jrich/opt/java/jdk-17.0.12+7/bin/java"
picard_jar = "/home/jrich/opt/picard.jar"
gatk = "/home/jrich/opt/gatk-4.6.0.0/gatk"
STRELKA_INSTALL_PATH = os.path.join(opt_dir, "strelka-2.9.10.centos6_x86_64")
VARSCAN_INSTALL_PATH = os.path.join(opt_dir, "VarScan.v2.3.9.jar")

tmp_dir = "tmp"
output_dir = "/Users/joeyrich/Desktop/local/varseek/logs"
reference_out_dir = "/Users/joeyrich/Documents/Caltech/Pachter/reference"
### ARGUMENTS ###

# # set random seeds
# random.seed(random_seed)
# np.random.seed(random_seed)

os.makedirs(opt_dir, exist_ok=True)

# define tmp subdirectories (to be deleted at the end)
os.makedirs(tmp_dir)  # purposely not using exist_ok=True to ensure that the directory is non-existent
out_dir_vk_build = os.path.join(tmp_dir, "vk_build")
update_df_out = os.path.join(out_dir_vk_build, "updated_df.csv")

script_dir = os.path.dirname(os.path.abspath(__file__))  # the parent directory of this current file (this file should be in scripts/)
vk_count_script_path = os.path.join(script_dir, "run_varseek_count_for_benchmarking_time_and_memory.py")
gatk_haplotypecaller_script_path = os.path.join(script_dir, "run_gatk_for_benchmarking_time_and_memory.py")
gatk_mutect2_script_path = os.path.join(script_dir, "run_gatk_for_benchmarking_time_and_memory.py")
strelka_script_path = os.path.join(script_dir, "run_strelka_for_benchmarking_time_and_memory.py")
varscan_script_path = os.path.join(script_dir, "run_varscan_for_benchmarking_time_and_memory.py")

star_output_file = os.path.join(output_dir, "STAR_time.txt")

# create synthetic reads
if k and w:
    assert k > w, "k must be greater than w"
    read_w = read_length - (k - w)  # note that this does not affect read length, just read *parent* length
else:
    read_w = read_length - 1


for tool in tools_to_benchmark:
    if tool not in all_supported_tools_to_benchmark:
        raise ValueError(f"Tool {tool} is not supported. Supported tools are: {all_supported_tools_to_benchmark}")


#* Make synthetic reads corresponding to the largest value in number_of_reads_list - if desired, I can replace this with real data
cosmic_mutations = pd.read_csv(cosmic_mutations_path)
number_of_mutations_to_sample = cosmic_mutations // 200
number_of_reads_max = max(number_of_reads_list) * 10**6  # convert to millions
fastq_output_path_max_reads = os.path.join(tmp_dir, f"reads_{number_of_reads_max}_fastq.fastq")

print(f"Building synthetic reads for {number_of_reads_max} reads")
_ = vk.sim(
    mutation_metadata_df = cosmic_mutations,
    fastq_output_path = fastq_output_path_max_reads,
    sample_type="all",
    number_of_mutations_to_sample=number_of_mutations_to_sample,
    strand=strand,
    number_of_reads_per_sample=100,  # 100 mutant, 100 wild-type
    read_length=read_length,
    seed=random_seed,
    add_noise_sequencing_error=add_noise_sequencing_error,
    add_noise_base_quality=add_noise_base_quality,
    error_rate=error_rate,
    error_distribution=error_distribution,
    max_errors=max_errors,
    with_replacement=False,
    gzip_output_fastq=False,
    sequences=reference_cdna_path,
    seq_id_column=seq_id_column,
    mut_column=mut_column,
    reference_out_dir=reference_out_dir,
    out_dir_vk_build=out_dir_vk_build,
    k=k,
    w=w
)

#* Download varseek index
if not os.path.exists(vk_ref_index_path) or not os.path.exists(vk_ref_t2g_path):
    vk_ref_index_dir = os.path.dirname(vk_ref_index_path)
    vk_ref_index_path = os.path.join(vk_ref_index_dir, "index.idx")
    vk_ref_t2g_path = os.path.join(vk_ref_index_dir, "t2g.txt")
    print(f"Downloading varseek index to {vk_ref_index_dir}")
    vk.ref(download="cosmic_cmc_cdna", out=vk_ref_index_dir)

#* install seqtk if not installed
if not is_program_installed(seqtk):
    subprocess.run("git clone https://github.com/lh3/seqtk.git", shell=True, check=True)
    subprocess.run("cd seqtk && make", shell=True, check=True)
    seqtk = os.path.join(script_dir, "seqtk/seqtk")

#* Download/build necessary files for alternative variant calling tools
if any(tool in tools_that_require_star_alignment for tool in tools_to_benchmark):  # check if any tool in tools_to_benchmark requires STAR alignment
    #* Download reference genome information
    reference_genome_fasta_url = "https://ftp.ensembl.org/pub/grch37/release-93/fasta/homo_sapiens/dna/Homo_sapiens.GRCh37.dna.primary_assembly.fa.gz"
    reference_genome_gtf_url = "https://ftp.ensembl.org/pub/grch37/release-93/gtf/homo_sapiens/Homo_sapiens.GRCh37.87.gtf.gz"
    genomes1000_vcf_url = "https://ftp.ensembl.org/pub/grch37/release-93/variation/vcf/homo_sapiens/1000GENOMES-phase_3.vcf.gz"

    os.makedirs(os.path.dirname(reference_genome_fasta), exist_ok=True)
    download_reference_genome_fasta_command = ["wget", "-O", f"{reference_genome_fasta}.gz", reference_genome_fasta_url]
    unzip_reference_genome_fasta_command = ["gunzip", f"{reference_genome_fasta}.gz"]

    os.makedirs(os.path.dirname(reference_genome_gtf), exist_ok=True)
    download_reference_genome_gtf_command = ["wget", "-O", f"{reference_genome_gtf}.gz", reference_genome_gtf_url]
    unzip_reference_genome_gtf_command = ["gunzip", f"{reference_genome_gtf}.gz"]

    os.makedirs(os.path.dirname(genomes1000_vcf), exist_ok=True)
    download_1000_genomes_command = ["wget", "-O", f"{genomes1000_vcf}.gz", genomes1000_vcf_url]
    unzip_1000_genomes_command = ["gunzip", f"{genomes1000_vcf}.gz"]

    if not os.path.exists(reference_genome_fasta):
        run_command_with_error_logging(download_reference_genome_fasta_command)
        run_command_with_error_logging(unzip_reference_genome_fasta_command)

    if not os.path.exists(reference_genome_gtf):
        run_command_with_error_logging(download_reference_genome_gtf_command)
        run_command_with_error_logging(unzip_reference_genome_gtf_command)

    if not os.path.exists(genomes1000_vcf):
        run_command_with_error_logging(download_1000_genomes_command)
        run_command_with_error_logging(unzip_1000_genomes_command)

    read_length_minus_one = read_length - 1
    star_genome_dir = os.path.join(tmp_dir, "star_genome")
    os.makedirs(star_genome_dir, exist_ok=True)

    if not os.path.exists(STAR):
        star_tarball = os.path.join(opt_dir, "2.7.11b.tar.gz")
        subprocess.run(["wget", "-O", star_tarball, "https://github.com/alexdobin/STAR/archive/2.7.11b.tar.gz"], check=True)
        subprocess.run(["tar", "-xzf", star_tarball, "-C", opt_dir], check=True)

    #* Build STAR index
    star_build_command = [
        STAR,
        "--runThreadN", str(threads),
        "--runMode", "genomeGenerate",
        "--genomeDir", star_genome_dir,
        "--genomeFastaFiles", reference_genome_fasta,
        "--sjdbGTFfile", reference_genome_gtf,
        "--sjdbOverhang", str(read_length_minus_one),
    ]

    if not os.listdir(star_genome_dir):
        elapsed_time = run_command_with_error_logging(star_build_command, track_time=True)
        with open(star_output_file, "w", encoding="utf-8") as f:
            f.write(f"STAR build runtime: {elapsed_time[0]} minutes, {elapsed_time[1]} seconds\n")

    #* Index reference genome
    if not os.path.exists(f"{reference_genome_fasta}.fai"):
        start_time = time.time()
        _ = pysam.faidx(reference_genome_fasta)
        minutes, seconds = divmod(time.time() - start_time, 60)
        with open(star_output_file, "a", encoding="utf-8") as f:
            f.write(f"Genome indexing runtime: {minutes} minutes, {seconds} seconds\n")

    #* Index 1000 genomes standard variants
    index_feature_file_command = [
        gatk, "IndexFeatureFile",
        "-I", genomes1000_vcf
    ]

    if not os.path.exists(f"{genomes1000_vcf}.idx"):
        run_command_with_error_logging(index_feature_file_command)

if ("gatk_haplotypecaller" in tools_to_benchmark or "gatk_mutect2" in tools_to_benchmark):
    if not is_program_installed(java):
        raise ValueError("Java is required to run GATK. Please install Java and ensure that it is in your PATH.")
        # below are commands that will install it on x64_linux
        # wget https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.12%2B7/OpenJDK17U-jdk_x64_linux_hotspot_17.0.12_7.tar.gz
        # tar -xvf OpenJDK17U-jdk_x64_linux_hotspot_17.0.12_7.tar.gz
    if not os.path.exists(picard_jar):
        subprocess.run(["wget", "https://github.com/broadinstitute/picard/releases/download/3.3.0/picard.jar", "-O", picard_jar], check=True)
    if not os.path.exists(gatk):
        os.chdir(opt_dir)
        gatk_dir_name = os.path.join(opt_dir, "gatk-4.6.0.0")
        subprocess.run(["wget", "https://github.com/broadinstitute/gatk/releases/download/4.6.0.0/gatk-4.6.0.0.zip", "-O", "gatk-4.6.0.0.zip"], check=True)
        subprocess.run(["unzip", "gatk-4.6.0.0.zip"], check=True)
        os.environ['PATH'] = f"{gatk_dir_name}:{os.environ['PATH']}"


if "strelka2" in tools_to_benchmark and not os.path.exists(STRELKA_INSTALL_PATH):
    strelka_tarball = f"{STRELKA_INSTALL_PATH}.tar.bz2"
    subprocess.run(["wget", "-O", strelka_tarball, "https://github.com/Illumina/strelka/releases/download/v2.9.10/strelka-2.9.10.centos6_x86_64.tar.bz2"], check=True)
    subprocess.run(["tar", "-xvjf", strelka_tarball, "-C", opt_dir], check=True)

if "varscan" in tools_to_benchmark and not os.path.exists(VARSCAN_INSTALL_PATH):
    subprocess.run(["wget", "-O", VARSCAN_INSTALL_PATH, "https://sourceforge.net/projects/varscan/files/VarScan.v2.3.9.jar/download"], check=True)


#* Run variant calling tools
for number_of_reads in number_of_reads_list:
    number_of_reads *= 10**6  # convert to millions
    if number_of_reads != number_of_reads_max:
        number_of_reads_fraction = number_of_reads / number_of_reads_max
        fastq_output_path = os.path.join(tmp_dir, f"reads_{number_of_reads}_fastq.fastq")
        seqtk_sample_command = f"{seqtk} sample -s {random_seed} {fastq_output_path_max_reads} {number_of_reads_fraction} > {fastq_output_path}"
        subprocess.run(seqtk_sample_command, shell=True, check=True)

    #* Variant calling: varseek
    if "varseek" in tools_to_benchmark:
        print(f"varseek, {number_of_reads} reads")
        output_file = os.path.join(output_dir, f"vk_count_threads_{threads}_reads_{number_of_reads}_time_and_memory.txt")
        argparse_flags = f"--index {vk_ref_index_path} --t2g {vk_ref_t2g_path} --disable_fastqpp --disable_clean --disable_summarize {fastq_output_path}"
        _ = report_time_and_memory_of_script(vk_count_script_path, output_file = output_file, argparse_flags = argparse_flags)

    if any(tool in tools_that_require_star_alignment for tool in tools_to_benchmark):
        #* STAR alignment
        star_alignment_dir = os.path.join(tmp_dir, "strelka2_simulated_data_dir")
        out_file_name_prefix = f"{star_alignment_dir}/sample_"
        aligned_and_unmapped_bam = f"{out_file_name_prefix}Aligned.sortedByCoord.out.bam"
        star_align_command = [
            STAR,
            "--runThreadN", str(threads),
            "--genomeDir", star_genome_dir,
            "--readFilesIn", fastq_output_path,
            "--sjdbOverhang", str(read_length_minus_one),
            "--outFileNamePrefix", out_file_name_prefix,
            "--outSAMtype", "BAM", "SortedByCoordinate",
            "--outSAMunmapped", "Within",
            "--outSAMmapqUnique", "60",
            "--twopassMode", "Basic"
        ]

        print(f"STAR alignment, {number_of_reads} reads")
        elapsed_time = run_command_with_error_logging(star_align_command, track_time=True)
        with open(star_output_file, "a", encoding="utf-8") as f:
            f.write(f"STAR alignment runtime for {number_of_reads} reads: {elapsed_time[0]} minutes, {elapsed_time[1]} seconds\n")

        #* Index BAM file
        bam_index_file = f"{aligned_and_unmapped_bam}.bai"
        if not os.path.exists(bam_index_file):
            start_time = time.time()
            _ = pysam.index(aligned_and_unmapped_bam)
            minutes, seconds = divmod(time.time() - start_time, 60)
            with open(star_output_file, "a", encoding="utf-8") as f:
                f.write(f"BAM indexing runtime for {number_of_reads} reads: {minutes} minutes, {seconds} seconds\n")
    
    if "gatk_haplotypecaller" in tools_to_benchmark:
        #* Variant calling: GATK HaplotypeCaller
        print(f"GATK HaplotypeCaller, {number_of_reads} reads")
        output_file = os.path.join(output_dir, f"gatk_haplotypecaller_threads_{threads}_reads_{number_of_reads}_time_and_memory.txt")
        argparse_flags = f"--synthetic_read_fastq {fastq_output_path} --reference_genome_fasta {reference_genome_fasta} --reference_genome_gtf {reference_genome_gtf} --star_genome_dir {star_genome_dir} --threads {threads} --read_length {read_length} --STAR {STAR} --java {java} --picard_jar {picard_jar} --gatk {gatk} --tmp {tmp_dir} --aligned_and_unmapped_bam {aligned_and_unmapped_bam}"
        _ = report_time_and_memory_of_script(gatk_haplotypecaller_script_path, output_file = output_file, argparse_flags = argparse_flags)

    if "gatk_mutect2" in tools_to_benchmark:
        #* Variant calling: GATK Mutect2
        print(f"GATK Mutect2, {number_of_reads} reads")
        output_file = os.path.join(output_dir, f"gatk_mutect2_threads_{threads}_reads_{number_of_reads}_time_and_memory.txt")
        argparse_flags = f"--synthetic_read_fastq {fastq_output_path} --reference_genome_fasta {reference_genome_fasta} --reference_genome_gtf {reference_genome_gtf} --star_genome_dir {star_genome_dir} --threads {threads} --read_length {read_length} --STAR {STAR} --java {java} --picard_jar {picard_jar} --gatk {gatk} --tmp {tmp_dir} --aligned_and_unmapped_bam {aligned_and_unmapped_bam}"
        _ = report_time_and_memory_of_script(gatk_mutect2_script_path, output_file = output_file, argparse_flags = argparse_flags)

    if "strelka2" in tools_to_benchmark:
        #* Variant calling: Strelka2
        print(f"Strelka2, {number_of_reads} reads")
        output_file = os.path.join(output_dir, f"strelka2_threads_{threads}_reads_{number_of_reads}_time_and_memory.txt")
        argparse_flags = f"--synthetic_read_fastq {fastq_output_path} --reference_genome_fasta {reference_genome_fasta} --reference_genome_gtf {reference_genome_gtf} --star_genome_dir {star_genome_dir} --threads {threads} --read_length {read_length} --STRELKA_INSTALL_PATH {STRELKA_INSTALL_PATH} --tmp {tmp_dir} --aligned_and_unmapped_bam {aligned_and_unmapped_bam}"
        _ = report_time_and_memory_of_script(strelka_script_path, output_file = output_file, argparse_flags = argparse_flags)

    if "varscan" in tools_to_benchmark:
        #* Variant calling: VarScan
        print(f"VarScan, {number_of_reads} reads")
        output_file = os.path.join(output_dir, f"varscan_threads_{threads}_reads_{number_of_reads}_time_and_memory.txt")
        argparse_flags = f"--synthetic_read_fastq {fastq_output_path} --reference_genome_fasta {reference_genome_fasta} --reference_genome_gtf {reference_genome_gtf} --star_genome_dir {star_genome_dir} --threads {threads} --read_length {read_length} --VARSCAN_INSTALL_PATH {VARSCAN_INSTALL_PATH} --tmp {tmp_dir} --aligned_and_unmapped_bam {aligned_and_unmapped_bam}"
        _ = report_time_and_memory_of_script(varscan_script_path, output_file = output_file, argparse_flags = argparse_flags)

    os.remove(fastq_output_path)

# delete temp directory
# os.system(f"rm -rf {tmp_dir}")  #!!! uncomment later to delete tmp directory
